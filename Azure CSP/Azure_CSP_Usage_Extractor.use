#################################################################
# 
#  This USE script will download the Azure CSP:
#
#	- Customers
#	- Subscriptions
#	- Usage Data    
#
#  Please consult https://docs.exivity.com/ for more info.
#
# ==========================================================
#                                                               
# This needs two parameters, FROM and TO date in: YYYYMMDD
#
# NOTE: FROM and TO date should not overlap more than 1 month.
#		In case it does overlap 1 month, it will reset the FROM
#		date to the last day of the FROM month. And the TO date
#		to the first day of the TO month. Support for overlapping
#		months will be included in a future release.
#																
#################################################################

if (${ARGC} != 2) {
	print "This requires 2 argument, the day to collect usage for, and the date following that day, both in yyyyMMdd format"
	terminate with error
} else {
	var today = ${ARG_1}
	var tomorrow = ${ARG_2}
}
	
if (${ARG_1} == ${ARG_2}) {
  print "FROM and TO date cannot be the same"
  terminate with error
}

if (${ARG_1} > ${ARG_2}) {
  print "TO date cannot be a date that lies before FROM date"
  terminate with error
}

# Validate the date formats
match date "^([0-9]{8})$" ${today}
if (${date.STATUS} != MATCH) {
	print Argument 1 error: ${today} is not in today format
	terminate with error
}

match date "^([0-9]{8})$" ${tomorrow}
if (${date.STATUS} != MATCH) {
	print Argument 2 error: ${tomorrow} is not in today format
	terminate with error
}

#==================== Configuration ====================#
#

# For testing and maintenance purposes
# If any online_customers or online_subscriptions are set to no then the data is
# retrieved from local JSON files on disk. These files are created when run with
# the options set to yes
#
# If either of those options are set to 'yes' then get_token must
# also be set to yes
#
loglevel DEBUGX

# Application ID of the Partner Center Web Application
public var client_id = "guid-of-your-partner-center-application" 
# secret that belongs to the client application GUID
public var secret = "secret-belonging-to-client-id"
# Your CSP domain, usually xxxx.onmicrosoft.com
public var MyDomain = "YourDomain.onmicrosoft.com"
# Standard location for writing extracted files, relative to %EXIVITY_HOME_PATH%
public var exportdir = "system/extracted/AzureCSP"

# default variables
var get_token = yes
var online_customers = yes
var online_subscriptions = yes

# default path variables
var customer_export_file = "${exportdir}/${today}_csp_customers.csv"
var subscriptions_export_file = "${exportdir}/${today}_csp_subscriptions.csv"
var usage_export_file = "${exportdir}/${today}_csp_usage.csv"
var json_filedir = "${exportdir}/json"

#
#=================  End Configuration ==================#

#=================  Date Formatting  ==================#

# Extract the day, month and year fields from the dates
match day "^[0-9]{6}([0-9]{2})" ${today}
if (${day.STATUS} != MATCH) {
	print Could not extract day from the supplied date (${today})
	terminate with error
} else {
	var day = ${day.RESULT}
}

match month "^[0-9]{4}([0-9]{2})[0-9]{2}" ${today}
if (${day.STATUS} != MATCH) {
	print Could not extract month from the supplied date (${today})
	terminate with error
} else {
	var month = ${month.RESULT}
}

match year "^([0-9]{4})[0-9]{4}" ${today}
if (${year.STATUS} != MATCH) {
	print Could not extract year from the supplied date (${today})
	terminate with error
} else {
	var year = ${year.RESULT}
}

match day "^[0-9]{6}([0-9]{2})" ${tomorrow}
if (${day.STATUS} != MATCH) {
	print Could not extract day from the supplied date (${tomorrow})
	terminate with error
} else {
	var tomorrow_day = ${day.RESULT}
}

match month "^[0-9]{4}([0-9]{2})[0-9]{2}" ${tomorrow}
if (${day.STATUS} != MATCH) {
	print Could not extract month from the supplied date (${tomorrow})
	terminate with error
} else {
	var tomorrow_month = ${month.RESULT}
}

match year "^([0-9]{4})[0-9]{4}" ${tomorrow}
if (${year.STATUS} != MATCH) {
	print Could not extract year from the supplied date (${tomorrow})
	terminate with error
} else {
	var tomorrow_year = ${year.RESULT}
}

#=================  End Date Formatting ==================#

# Set some variables to facilitate running for 
# multiple days within a single month.
var date_diff = ${tomorrow_day}
var date_diff -= ${day}
var next_day = ${day}

if (${month} != ${tomorrow_month}) {
  print "WARNING! spanning two months not available for > 1 day."
  print "Resetting day variable to last day of the FROM month ..."
  get_last_day_of ${year}${month} as lastday
  print "Resetting tomorrow_day variable to first day of the to month ..."
  print "the last day of this month is: ${lastday}"
  #var tomorrow_day = 01
  
  var date_diff = ${lastday}
  if (${lastday} == ${day}) { 
     var next_day = 00
  }
  else {
    var next_day = ${day}
  }
  var date_diff -= ${day}
  var date_diff += ${tomorrow_day}
  var tomorrow_month = ${month}
  var month_flag = "yes"
  
} else {
  var lastday = ${day}
  var month_flag = "no"
}



loop date_range ${date_diff} {
  
  if ((${day} == ${lastday}) && (${month_flag} == "yes")){
  var next_day = 00
  var customer_export_file = "${exportdir}/${year}${month}${day}_csp_customers.csv"
  var subscriptions_export_file = "${exportdir}/${year}${month}${day}_csp_subscriptions.csv"
  var usage_export_file = "${exportdir}/${year}${month}${day}_csp_usage.csv"
  var tomorrow_month += 1
  } if ((${day} > ${lastday}) && (${month_flag} == "yes")) {
  var next_day = 01
  var day = 01
  var month2 = ${tomorrow_month}
  var month = ${tomorrow_month}
  var customer_export_file = "${exportdir}/${year}${month2}${day}_csp_customers.csv"
  var subscriptions_export_file = "${exportdir}/${year}${month2}${day}_csp_subscriptions.csv"
  var usage_export_file = "${exportdir}/${year}${month2}${day}_csp_usage.csv"
  
  } else {
  var customer_export_file = "${exportdir}/${year}${month}${day}_csp_customers.csv"
  var subscriptions_export_file = "${exportdir}/${year}${month}${day}_csp_subscriptions.csv"
  var usage_export_file = "${exportdir}/${year}${month}${day}_csp_usage.csv"
  }


  print "Set customers export csv to ${customer_export_file} ..."
  csv "customers" = "${customer_export_file}"
  csv add_headers "customers" ID tenantId Name Domain Type Relationship
  csv fix_headers "customers"
  
  print "Set subscriptions export csv to ${subscriptions_export_file} ..."
  csv "subscriptions" = ${subscriptions_export_file}
  csv add_headers "subscriptions" customer_id tenant_id companyName subscription_id offerId offerName quantity unitType creationDate effectiveStartDate commitmentEndDate status autoRenewEnabled billingType contractType
  csv fix_headers "subscriptions"
  
  print "Set usage export csv to ${usage_export_file} ..."
  csv "usage" = ${usage_export_file}
  csv add_headers "usage" customer_id subscription_id usageStartTime usageEndTime
  csv add_headers "usage" resource_id resource_name resource_category resource_subcategory
  csv add_headers "usage" quantity unit resourceUri location partNumber orderNumber objectType region
  csv fix_headers "usage"
  

  print "This is date_range loop number: ${date_range.COUNT}"
  var next_day += 1
  print The day diff is: ${date_diff} the day is ${day} and next_Day is ${next_day}
  # Format of a start or end date argument to Azure CSP is: 2016-12-01T00:00:00%2b01:00 
  var start_time = ${year}-${month}-${day}T00:00:00
  var end_time = ${tomorrow_year}-${tomorrow_month}-${next_day}T00:00:00
  
  print This is the start_time: ${start_time} and this is the end_time: ${end_time}
  
#  var customer_export_file = "${exportdir}/${year}${month}${day}_csp_customers.csv"
#  var subscriptions_export_file = "${exportdir}/${year}${month}${day}_csp_subscriptions.csv"
#  var usage_export_file = "${exportdir}/${year}${month}${day}_csp_usage.csv"
  
  print I have created the filee ${usage_export_file}

  if (${get_token} == yes)
  {
  	# Get an AD token from login.windows.net
      print "Getting AD Token"
  	
  	# Set up the HTTP request parameters
  	set http_body data "grant_type=client_credentials&client_id=${client_id}&client_secret=${secret}&resource=https%3A%2F%2Fgraph.windows.net"
  	# ====== Possible alternative auth method with user/pass if required ===== #
  	# set http_body data "resource=https%3A%2F%2Fapi.partnercenter.microsoft.com&client_id=${client_id}&grant_type=password&username=${username}&password=${password}&scope=openid&prompt=consent"
  	# ======================================================================== #
  	set http_header "Content-Type: application/x-www-form-urlencoded"
  	set http_savefile "${json_filedir}/http_savefile.json"
  	# Get AD Token and cache it in a buffer called {token}
  	buffer token = http POST "https://login.windows.net/${MyDomain}/oauth2/token"
  	if (${HTTP_STATUS_CODE} != 200) {
  		print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
  		print The server response was:
  		json format {token} 
  		print {token}
  		terminate with error
  	}
  
  	# Create a variable called ${access_token} from the AD token in {token}
  	var access_token = $JSON{token}.[access_token]
  	discard {token}
  
  	# Use the access_token to get an App_User token
    print "Getting AU Token"
  	# Reset headers as we want to create a new Authorization: header
  	clear http_headers
  	
  	# Set up the HTTP request parameters
  	var partnerRoot = "https://api.partnercenter.microsoft.com"
  	set http_header "Content-Type: application/x-www-form-urlencoded"
  	set http_header "Authorization: Bearer ${access_token}"	
  	set http_body data "grant_type=jwt_token"
  
  	# Get the new token into a buffer called {token}
  	buffer token = http POST ${partnerRoot}/generatetoken
  	if (${HTTP_STATUS_CODE} != 200) {
  		print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
  		print The server response was:
  		json format {token} 
  		print {token}
  		terminate with error
  	}
  
  	# Create a variable called ${AUtoken} from the App+User token in {token}
  	# 2017-07 - App+User is not needed. Setting AUToken to access_token
  	var AUtoken = ${access_token}
  	discard {token}
  }
  
  #======== OBTAINING CUSTOMER ==========#
  #
  
  # Use the AUtoken to get a list of customers (and export them as CSV)
  print "Getting customer list"
  clear http_headers
  set http_header "Accept: application/json"
  set http_header "Authorization: Bearer ${AUtoken}"	
  buffer customers = http GET "${partnerRoot}/v1/customers"
  if (${HTTP_STATUS_CODE} != 200) {
  	print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
  	print Exiting
  	terminate with error
  }
  
  loop customers_loop {
    # Iterate through the customers and populate the file
    foreach $JSON{customers}.[items] as this_customer
    {
    	# Define the fields to export to match the headers
    	csv write_field customers $JSON(this_customer).[id]
    	csv write_field customers $JSON(this_customer).[companyProfile].[tenantId]
    	csv write_field customers $JSON(this_customer).[companyProfile].[companyName]
    	csv write_field customers $JSON(this_customer).[companyProfile].[domain]
    	csv write_field customers $JSON(this_customer).[attributes].[objectType]
    	csv write_field customers $JSON(this_customer).[relationshipToPartner]
    }
    
    #========== NOW GET SUBSCRIPTIONS FOR FIRST BATCH OF CUSTOMERS ============#
    #
    
    print "Exporting subscriptions to ${subscriptions_export_file}"
    foreach $JSON{customers}.[items] as this_customer
    {
    	# For each customer ID ...
    	var c_name = $JSON(this_customer).[companyProfile].[companyName]
    	var c_id = $JSON(this_customer).[id]
    	print Processing customer ${this_customer.COUNT} (${c_name})
    
    	# ... get their subscriptions  
    	if (${online_subscriptions} == no) {
    		buffer subscriptions = FILE "${json_filedir}/${today}_subs_${c_id}.json"
    	} else {
    		# Create the customer savefiles for offline use and get the data from Azure
    		buffer subscriptions = http get ${partnerRoot}/v1/customers/${c_id}/subscriptions
    		json format {subscriptions}
    		save {subscriptions} as "${json_filedir}/${today}_subs_${c_id}.json"
    	}
    	
    	var reseller_code = $JSON{subscriptions}.[code]
    	if (("${reseller_code}" != 20002) && ("${reseller_code}" != 3000)) {
    		# For each subscription export the required CSV fields
    		foreach $JSON{subscriptions}.[items] as this_subscription {
    			csv write_field "subscriptions" ${c_id}
    			csv write_field "subscriptions" $JSON(this_customer).[companyProfile].[tenantId]
    			csv write_field "subscriptions" $JSON(this_customer).[companyProfile].[companyName]
    			csv write_field "subscriptions" $JSON(this_subscription).[id]
    			csv write_field "subscriptions" $JSON(this_subscription).[offerId]
    			csv write_field "subscriptions" $JSON(this_subscription).[offerName]
    			csv write_field "subscriptions" $JSON(this_subscription).[quantity]
    			csv write_field "subscriptions" $JSON(this_subscription).[unitType]
    			csv write_field "subscriptions" $JSON(this_subscription).[creationDate]
    			csv write_field "subscriptions" $JSON(this_subscription).[effectiveStartDate]
    			csv write_field "subscriptions" $JSON(this_subscription).[commitmentEndDate]
    			csv write_field "subscriptions" $JSON(this_subscription).[status]
    			csv write_field "subscriptions" $JSON(this_subscription).[autoRenewEnabled]
    			csv write_field "subscriptions" $JSON(this_subscription).[billingType]
    			csv write_field "subscriptions" $JSON(this_subscription).[contractType]   
    		}
    	} else {
    		print "Skipping customer ${c_name} with id: ${c_id} - this is not an acccount managed by your reseller, or it is a unknown customer."
    	}
    }	
  
    #========== OBTAINING AZURE USAGE ===============#
    #
    print "Retrieving Azure usage data"
    
    foreach $JSON{customers}.[items] as this_customer
    {
    	# For each customer ID ...
    	var customer_id = $JSON(this_customer).[id]
    	print Searching subscriptions of customer id ${customer_id} for Azure usage
    	# ... get their subscriptions  
    	buffer subscriptions = FILE "${json_filedir}/${today}_subs_${customer_id}.json"
    	
    	# this is to check for reseller relationship with customer
    	var reseller_code = $JSON{subscriptions}.[code]
    	print "Reseller code is now: $JSON{subscriptions}.[code]"
    	if (("${reseller_code}" != 20002) && ("${reseller_code}" != 3000))
    	{
    		# For each subscription that has an offerName of Microsoft Azure
    		foreach $JSON{subscriptions}.[items] as this_subscription {		
    			var offerName = $JSON(this_subscription).[offerName]
    			if ("${offerName}" == "Microsoft Azure")
    			{
    				# Get the subscription ID
    				var subscription_id = $JSON(this_subscription).[id]
    
    				# Assume there will be no continuation required
    				var continuationToken = none
    
    				# We'll loop here as there may be continuation required which will involve
    				# additional HTTP requests for the usage for this customer
    				var totalrecords = 0
    				loop usageloop {
    					# Query the usage for the customer_id and subscription_id
    					if (${usageloop.COUNT} == 1) {
    						# Initial request
    						print Found Microsoft Azure subscription (subscription id: ${subscription_id})
    						print Getting up to 1000 usage records ...
    						clear http_headers
    						set http_header "Accept: application/json"
    						set http_header "Authorization: Bearer ${AUtoken}"
    
    						print getting usage for start_time=${start_time}
    						buffer usage = http GET "${partnerRoot}/v1/customers/${customer_id}/subscriptions/${subscription_id}/utilizations/azure?start_time=${start_time}&end_time=${end_time}&granularity=daily&showDetails=true"
    						json format {usage}
    						save {usage} as "${json_filedir}\${today}_usage_${customer_id}_${subscription_id}.json"
    					} else {
    						# Need to use the continuation token
    						clear http_headers
    						set http_header "Accept: application/json"
    						set http_header "Authorization: Bearer ${AUtoken}"
    						set http_header "MS-ContinuationToken: ${continuationToken}"
    						print Calling: "${partnerRoot}/v1/${continuation_uri}"
    						buffer usage = http GET "${partnerRoot}/v1/${continuation_uri}"
    						json format {usage}
    						save {usage} as "${json_filedir}/${today}_usage_${customer_id}_${subscription_id}_${usageloop.COUNT}.json"
    					}
    					if (${HTTP_STATUS_CODE} != 200) {
    						print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
    						print failing to obtain use for customer ${customer_id} with subscription id ${subscription_id}
    					}
    
    					# Check the total count returned
    					var usagecount = $JSON{usage}.[totalCount]
    
  						if (${usagecount} == 1000) {
  							# Extract the continuation token
  							foreach $JSON{usage}.[links].[next].[headers] as this_header {
  								var hkey = $JSON(this_header).[key]
  								if (${hkey} == MS-ContinuationToken) {
  									# Get the continuation token 
  									var continuationToken = $JSON(this_header).[value]
  									# Get the continuation URI for the next call
  									var continuation_uri = $JSON{usage}.[links].[next].[uri]
  									print Continuation URI is: ${continuation_uri}
  									exit_loop
  								}
  							}
  						}
  						
  						if (${usagecount} == 0) {
  						  print "Not consumption found for this customer in the selected time period."
  						  exit_loop
  						}
    					
    					# Render the usage as a CSV file
    					foreach $JSON{usage}.[items] as this_item {
    						csv write_fields "usage" ${customer_id} ${subscription_id}
    						csv write_fields "usage" $JSON(this_item).[usageStartTime] $JSON(this_item).[usageEndTime]
    						csv write_fields "usage" $JSON(this_item).[resource].[id] $JSON(this_item).[resource].[name]
    						csv write_fields "usage" $JSON(this_item).[resource].[category] $JSON(this_item).[resource].[subcategory]
    						csv write_fields "usage" $JSON(this_item).[quantity] $JSON(this_item).[unit]
    						csv write_fields "usage" $JSON(this_item).[instanceData].[resourceUri]
    						csv write_fields "usage" $JSON(this_item).[instanceData].[location]
    						csv write_fields "usage" $JSON(this_item).[instanceData].[partNumber]
    						csv write_fields "usage" $JSON(this_item).[instanceData].[orderNumber]
    						csv write_fields "usage" $JSON(this_item).[attributes].[objectType]
    						csv write_fields "usage" $JSON(this_item).[resource].[region]
    						
    					}
    					
    					if (${usagecount} == 1000) {
    						print ${totalrecords} usage records received, getting up to 1000 more ...
    						var totalrecords += 1000
    					} else {
    						var totalrecords += ${usagecount}
    						print ${totalrecords} usage records received
    						# No more continuation required
    						exit_loop
    					}
    				} # End loop
    			} # End if
    		} # End foreach
    	} # End if reseller_code
    }	

    #========== NOW GET THE FOLLOWING BATCH OF CUSTOMERS ============#
    #
    
    # get the link and token from the json
    var totalCount = $JSON{customers}.[totalCount]
    var next_link = $JSON{customers}.[links].[next].[uri]
    var continuationToken = $JSON{customers}.[continuationToken]
    
    # skip if we don't have a next_link
    if (${next_link} == "EXIVITY_NOT_FOUND") {
    print "no next link, we can finish."
    exit_loop
    }
    
    # exit if there isn't a new token
    if ("${totalCount}" < 499) {
      print "no new continuationToken, we can finish"
      exit_loop
    }
    
    print "this is the total count: ${totalCount}"
    print "this is the next link: ${next_link}"
    print "this is the continuationToken: ${continuationToken}"
  
    # Need to use the continuation token
  	print "Calling continuationToken ... "
  	clear http_headers
  	set http_header "Accept: application/json"
  	set http_header "Authorization: Bearer ${access_token}"
  	set http_header "MS-ContinuationToken: ${continuationToken}"
  	print Calling: "${partnerRoot}/v1${next_link}"
  	buffer customers = http GET "${partnerRoot}/v1${next_link}"
  	json format {customers}
  	save {customers} as "${json_filedir}/${today}_customers_${customers_loop.COUNT}.json"
  	
  	if (${HTTP_STATUS_CODE} != 200) {
  		print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
  		terminate with error
  	}

  } # end of customer loop
  
  csv close "customers"
  csv close "subscriptions"
  csv close "usage"
  print Closing files

  # When running in a loop, we can skip getting a new token,
  # obtaining customers, and subscriptions
  var get_token = no
  var online_customers = no
  var online_subscriptions = no
  
  # increase day with 1 in crease we are running for a date range
  var day += 1
}