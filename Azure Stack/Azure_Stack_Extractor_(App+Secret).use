############################################################################
#
# THIS IS THE RECOMMENDED EXTRACTOR FOR AZURE STACK - UPDATED 20180418
#
# This template is used for obtaining consumption data from Azure Stack 
# Required parameters are from and to date in yyyyMMdd : 20180101 20180102
# 
# NOTE: you should always request consumption for 1 day at a time 
#
# Please configure your specifics in the "Configuration" part below
#
############################################################################

# Check if we have two parameters (from and to date)
if (${ARGC} != 2)
{
	print This requires 2 argument, the day to collect usage for, and the date following that day, both in yyyyMMdd format
	terminate
} else {
	var today = ${ARG_1}
	var tomorrow = ${ARG_2}
}

# Validate the date formats
match date "^([0-9]{8})$" ${today}
if (${date.STATUS} != MATCH) {
	print Argument 1 error: ${today} is not in today format
	terminate
}

match date "^([0-9]{8})$" ${tomorrow}
if (${date.STATUS} != MATCH) {
	print Argument 2 error: ${tomorrow} is not in today format
	terminate
}

#==================== Configuration ====================#
#

# adjust log detail to: DEBUG, INFO, WARN 
loglevel INFO

# Exivity Azure AD Client ID created using and admin account, and has the reader role for the consumption API
public var client_id = "<client-id-guid>"
# Exivity Azure AD C Secret
public var secret = "<secret-that-goes-with-client-id>"
# You domain
public var MyDomain = "yourdomain.onmicrosoft.com"
# Your provider subscription GUID
public var provider_sub = "<your-provider-subscription-guid>"
# hostname of adminmanagement 
public var management_hostname = "adminmanagement.you.domain.com" 
# place your audience guid here
public var audience = "<audience-guid>" 
# Exivity Resource URI for the application. Typically this is https://${management_hostname}/${audience}
public var resource_uri = "https://${management_hostname}/${audience}"
# can be changed, but daily is recommended
public var granularity = "daily" 

# Export directory for writing data
public var exportdir = "system\\extracted\\AzureStack"
var customer_export_file = "${exportdir}\${today}_stack_customers.csv"
var subscriptions_export_file = "${exportdir}\${today}_stack_subscriptions.csv"
var usage_export_file = "${exportdir}\${today}_stack_usage.csv"
var json_filedir = "${exportdir}\json"

# from here everything should be standard
var ARM_endpoint = "https://${management_hostname}"
var auth_endpoint = "https://login.windows.net"


#
#=================  End Configuration ==================#

#=================  Date Formatting  ==================#

# Extract the day, month and year fields from the dates
match day "^[0-9]{6}([0-9]{2})" ${today}
if (${day.STATUS} != MATCH) {
	print Could not extract day from the supplied date (${today})
	terminate
} else {
	var day = ${day.RESULT}
}

match month "^[0-9]{4}([0-9]{2})[0-9]{2}" ${today}
if (${day.STATUS} != MATCH) {
	print Could not extract month from the supplied date (${today})
	terminate
} else {
	var month = ${month.RESULT}
}

match year "^([0-9]{4})[0-9]{4}" ${today}
if (${year.STATUS} != MATCH) {
	print Could not extract year from the supplied date (${today})
	terminate
} else {
	var year = ${year.RESULT}
}

match day "^[0-9]{6}([0-9]{2})" ${tomorrow}
if (${day.STATUS} != MATCH) {
	print Could not extract day from the supplied date (${tomorrow})
	terminate
} else {
	var tomorrow_day = ${day.RESULT}
}

match month "^[0-9]{4}([0-9]{2})[0-9]{2}" ${tomorrow}
if (${day.STATUS} != MATCH) {
	print Could not extract month from the supplied date (${tomorrow})
	terminate
} else {
	var tomorrow_month = ${month.RESULT}
}

match year "^([0-9]{4})[0-9]{4}" ${tomorrow}
if (${year.STATUS} != MATCH) {
	print Could not extract year from the supplied date (${tomorrow})
	terminate
} else {
	var tomorrow_year = ${year.RESULT}
}

# Format of a start or end date argument to Azure Stack is: 2016-12-01T00:00:00%2b01:00 
var start_time = "${year}-${month}-${day}T00:00:00-00:00"
var end_time = "${tomorrow_year}-${tomorrow_month}-${tomorrow_day}T00:00:00-00:00"

#=================  End Date Formatting ==================#

clear http_headers
# Get an AD token from login.windows.net
print "Getting AD Token"

# Set up the HTTP request parameters
set http_body data "grant_type=client_credentials&client_id=${client_id}&client_secret=${secret}&resource=${resource_uri}"
set http_header "Content-Type: application/x-www-form-urlencoded"
set http_savefile "${json_filedir}\http_savefile.json"
buffer token = http POST "${auth_endpoint}/${MyDomain}/oauth2/token"
if (${HTTP_STATUS_CODE} != 200) {
	print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
	print The server response was:
	json format {token} 
	print {token}
	terminate
}

print "Succesfully authenticated!"


# Create a variable called ${access_token} from the AD token in {token}
var access_token = "$JSON{token}.[access_token]"
var refresh_token = "$JSON{token}.[refresh_token]"
print "access token is ${access_token}"
print "refresh token is ${refresh_token}"
discard {token}

print Retrieving Azure usage data

csv "usage" = ${usage_export_file}
csv add_headers "usage" id name type subscriptionId usageStartTime usageEndTime quantity meterId
csv add_headers "usage" resourceUri location tags additionalInfo
#csv add_headers "usage" ServiceType ImageType
csv fix_headers "usage"

# Assume there will be no continuation required
var continuationToken = "none"

# We'll loop here as there may be continuation required which will involve
# additional HTTP requests for the usage for this customer
var totalrecords = "0"
loop usageloop {
	# Query the usage for the customer_id and subscription_id
	if (${usageloop.COUNT} == 1) {
		# Initial request
		print Getting up to 1000 usage records ...
		clear http_headers
		set http_savefile "${json_filedir}\http_consumption_init-1k.json"
		set http_header "Accept: application/json"
		set http_header "Authorization: Bearer ${access_token}"

		print getting usage for start_time=${start_time}
		# do the request for consumption
    buffer usage = http GET "${ARM_endpoint}/subscriptions/${provider_sub}/providers/Microsoft.Commerce/subscriberUsageAggregates?reportedStartTime=${start_time}&reportedEndTime=${end_time}&aggregationGranularity=${granularity}&api-version=2015-06-01-preview"
    
    if (${HTTP_STATUS_CODE} != 200) {
    	print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
    	print The server response was:
    	json format {usage} 
    	print {usage}
    	terminate
    }
    print Succesfully obtained usage
    json format {usage}
		save {usage} as "${json_filedir}\${today}_usage_azure_stack_${provider_sub}.json"
		# set pevious link to next link
		var previous_link = $JSON{usage}.[nextLink]
	} else {
	  
	  # first check if we got a new continuationToken
	  # if its idential as the last call, we should be finished
	  if ( ${continuation_uri} == ${previous_link} ) {
	    # we're done so exit loop
	    exit_loop
	  } else {
	    # we got a new link to call
	    var previous_link = $JSON{usage}.[nextLink]
	  }
	  
		# Need to use the continuation token
		print "Calling continuationToken ... "
		clear http_headers
		set http_header "Accept: application/json"
		set http_header "Authorization: Bearer ${access_token}"
		set http_header "MS-ContinuationToken: ${continuationToken}"
		print Calling: "${continuation_uri}"
		buffer usage = http GET "${continuation_uri}"
		json format {usage}
		save {usage} as "${json_filedir}\${today}_usage_azure_stack${provider_sub}_${usageloop.COUNT}.json"
	}
	if (${HTTP_STATUS_CODE} != 200) {
		print Got HTTP status ${HTTP_STATUS_CODE}, expected a status of 200
		print failing to obtain use for customer ${customer_id} with subscription id ${subscription_id}
		
	}

	# Check the total count returned
	#var usagecount = $JSON{usage}.[totalCount]
	var usagecount = 800
  
	if (${usagecount} == 1000) {
		# Extract the continuation token
				var continuation_uri = $JSON{usage}.[nextLink]
				print Continuation URI is: ${continuation_uri}
				exit_loop
			}
	
	# Render the usage as a CSV file
	foreach $JSON{usage}.[value] as this_item {
		csv write_fields "usage" $JSON(this_item).[id]
		csv write_fields "usage" $JSON(this_item).[name]
		csv write_fields "usage" $JSON(this_item).[type]
		csv write_fields "usage" $JSON(this_item).[properties].[subscriptionId]
		csv write_fields "usage" $JSON(this_item).[properties].[usageStartTime]
		csv write_fields "usage" $JSON(this_item).[properties].[usageEndTime]
		#csv write_fields "usage" $JSON(this_item).[properties].[instanceData]
		csv write_fields "usage" $JSON(this_item).[properties].[quantity]
		csv write_fields "usage" $JSON(this_item).[properties].[meterId]
		
		# process the embedded json
		buffer embed_buffer = data "$JSON(this_item).[properties].[instanceData]"
		csv write_fields "usage" $JSON{embed_buffer}.[Microsoft.Resources].[resourceUri]
		csv write_fields "usage" $JSON{embed_buffer}.[Microsoft.Resources].[location]
		csv write_fields "usage" $JSON{embed_buffer}.[Microsoft.Resources].[tags]
		csv write_fields "usage" $JSON{embed_buffer}.[Microsoft.Resources].[additionalInfo]
		discard {embed_buffer}
    
	}
	
	var continuation_uri = $JSON{usage}.[nextLink]
	print "continuation_uri is now: ${continuation_uri}"
	if ( (${continuation_uri.LENGTH} > 17) && (${totalrecords} > 0) ) {
		print ${totalrecords} usage records received, getting up to 1000 more ...
		var totalrecords += 1000
	} else {
		print Approx. ${totalrecords} usage records received
		# No more continuation required
		exit_loop
	}
} # End If
csv close "usage"
discard {usage}
